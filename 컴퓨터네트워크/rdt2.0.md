**패킷 안의 비트들이 하위 채널에서 손상되는 모델이다.**

일반적으로 이러한 비트 오류는 패킷이 전송 도는 전파되거나 버퍼링될 때 네트워크의 물리적인 구성요소에서 발생한다.

  

### 자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜
- `긍정 확인응답(positive acknowledgment, “OK”)`
- `부정 확인응답(negative acknowledgment, “그것을 반복해주세요”)`

이러한 제어 메시지는 정확하게 수신되었는지 또는 잘못 수신되어 반복이 필요한지를 수신자가 송신자에게 알려줄 수 있게 한다.

  

**비트 오류를 처리하기 위해** 기본적으로 다음과 같은 세 가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다.

  

#### 오류 검출

> 비트 오류가 발생했을 때 수신자가 검출할 수 있는 기능이 필요하다. → checksum

이러한 기술은 수신자가 패킷 비트 오류를 검출하고 복구할 수 있게 해준다.

  

#### 수신자 피드백
> 송신자가 수신자의 상태를 알기 위한 유일한 방법은 수신자가 송신자에게 피드백을 제공하는 것이다.

수신자의 상태 : 패킷이 정확하게 수신되었는지 아닌지 등

  

e.g., rdt2.0 프로토콜에서은 수신자로부터 송신자 쪽으로 ACK와 NAK 패킷들을 전송할 것이다.

- `긍정 확인 응답(ACK)`
- `부정 확인 응답(NAK)`

→ 이러한 패킷은 단지 한 비트 길이면 된다. (0 또는 1)

  

#### 재전송
> 수신자에서 오류를 가지고 수신된 패킷은 송신자에 의해 재전송(retransmit)된다.

  

### rdt2.0에 대한 FSM

#### 송신자

[![rdt2.0 - 송신자](https://user-images.githubusercontent.com/86337233/211394874-2e37ba36-b8c3-454a-aa09-836435f51421.png)](https://user-images.githubusercontent.com/86337233/211394874-2e37ba36-b8c3-454a-aa09-836435f51421.png)  
  

2개의 상태가 존재한다.

1. **왼쪽 상태**에서 송신 측 프로토콜은 상위 계층으로부터 **데이터가 전달되기를 기다린다.**
    
    `rdt_sent(data)` 이벤트가 발생하면,
    
    1. 송신자는 패킷 체크섬과 함께 전송될 데이터를 포함하는 패킷(`sndpkt`)을 생성하고,
    2. 그 패킷을 `udt_send(sndpkt)` 동작을 통해 전송한다.
2. **오른쪽 상태**에서 송신자 프로토콜은 수신자로부터의 **ACK 또는 NAK 패킷을 기다린다.**
    
    1. 만약 `ACK` 패킷이 수신된다면 (`rdt_rcv(rcvpkt) && isACK(rcvpkt)`)
        - 가장 최근에 전송된 패킷이 정확하게 수신되었음을 의미한다.
        - 따라서 프로토콜은 상위 계층으로부터 데이터를 기다리는 상태로 돌아간다.
    2. 만약 `NAK`가 수신된다면
        1. 프로토콜은 마지막 패킷을 재전송한다.
        2. 재전송된 데이터 패킷에 대한 응답으로 수신자에 의해 응답하는 ACK 또는 NAK를 기다린다.

  

rdt2.0과 같은 프로토콜은 `전송 후 대기(stop-and-wait) 프로토콜`이다.

> 💡 송신자가 ACK 또는 NAK를 기다리는 상태에 있을 때, **상위 계층으로부터 더 이상의 데이터를 전달받을 수 없다.**

즉, `rdt_send()` 이벤트는 발생할 수 없으며, 이는 오직 송신자가 ACK를 수신하고 이 상태를 떠난 후에 발생할 것이다.

  

따라서 송신자는 **수신자가 현재의 패킷을 정확하게 수신했음을 확신하기 전까지** 새로운 데이터를 전달하지 않는다.

  

#### 수신자

[![rdt2.0 - 수신자](https://user-images.githubusercontent.com/86337233/211394877-619eb70a-cbc0-4e6c-bd47-b29a80d28521.png)](https://user-images.githubusercontent.com/86337233/211394877-619eb70a-cbc0-4e6c-bd47-b29a80d28521.png)  
  

단일 상태를 갖는다.

패킷이 도착했을 때, 수신자는 수신된 패킷이 손상되었는지 아닌지에 따라 `ACK` 또는 `NAK`로 응답한다.

  

### rdt2.0의 결함

여기서는 `ACK 또는 NAK 패킷이 손상될 수 있다`는 가능성을 고려하지 않았다.

만약 ACK 또는 NAK가 손상되었다면, 송신자는 수신자가 전송된 데이터의 마지막 부분을 올바르게 수신했는지를 알 방법이 없다.

  

> 대안 1 : 송신자가 검출뿐만 아니라 비트 오류로부터 회복할 수 있도록 **충분한 체크섬 비트들을 추가한다.**

이 방식은 패킷이 손상될 수 있으나 손실되지는 않는 채널의 경우에는 즉각적으로 문제를 해결할 수 있다.

  

> 대안 2 : 송신자가 왜곡된 ACK 또는 NAK 패킷을 수신할 때 **현재 데이터 패킷을 단순히 다시 송신한다.**

그러나 이 방식은 송신자에게 수신자 간의 채널로 `중복 패킷(duplicate packet)`을 전송한다.

- 송신자 입장에서는 마지막으로 전송된 ACK 또는 NAK가 송신자에게 정확하게 수신됐는지를 알 수 없다.
- 수신자 입장에서는 도착하는 패킷이 새로운 데이터를 포함하고 있는 것인지 아니면 재전송인지를 사전에 알 수 없다.

  

### 해결책

> 💡 데이터 패킷에 새로운 필드를 추가하고 이 필드 안에 `순서 번호(sequence number)`를 삽입하는 방식으로 데이터 패킷에 송신자가 번호를 붙인다.

_이는 현존하는 데이터 전송 프로토콜에 채택된 방법이다._

수신자는 수신된 패킷이 재전송인지를 결정할 때는 이 순서 번호만 확인하면 된다.